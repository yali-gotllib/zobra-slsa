name: Generic SLSA Provenance

on:
  push:
    tags:
      - 'v*'
      - 'go-v*'
      - 'py-v*'
      - 'node-v*'
  workflow_dispatch:
    inputs:
      artifact_type:
        description: 'Type of artifact to build (auto, go, python, nodejs, generic)'
        required: false
        default: 'auto'
        type: choice
        options:
          - auto
          - go
          - python
          - nodejs
          - generic
      tag:
        description: 'Tag to generate provenance for'
        required: false
        default: ''
      build_command:
        description: 'Custom build command (for generic type)'
        required: false
        default: ''
      artifact_pattern:
        description: 'Pattern to match artifacts (for generic type)'
        required: false
        default: '*'

permissions: read-all

jobs:
  # Detect project type and configure build parameters
  detect:
    runs-on: ubuntu-latest
    outputs:
      artifact_type: ${{ steps.detect.outputs.artifact_type }}
      build_command: ${{ steps.detect.outputs.build_command }}
      setup_command: ${{ steps.detect.outputs.setup_command }}
      artifact_pattern: ${{ steps.detect.outputs.artifact_pattern }}
      artifact_path: ${{ steps.detect.outputs.artifact_path }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.tag || github.ref }}

      - name: Detect project type and configure build
        id: detect
        run: |
          set -euo pipefail
          
          # Use manual input if provided
          if [ "${{ github.event.inputs.artifact_type }}" != "auto" ] && [ "${{ github.event.inputs.artifact_type }}" != "" ]; then
            ARTIFACT_TYPE="${{ github.event.inputs.artifact_type }}"
            echo "ðŸŽ¯ Using manual artifact type: $ARTIFACT_TYPE"
          else
            # Auto-detect based on files present
            echo "ðŸ” Auto-detecting project type..."
            
            if [ -f "go.mod" ]; then
              ARTIFACT_TYPE="go"
              echo "ðŸ“¦ Detected Go project (go.mod found)"
            elif [ -f "pyproject.toml" ] || [ -f "setup.py" ] || [ -f "setup.cfg" ]; then
              ARTIFACT_TYPE="python"
              echo "ðŸ Detected Python project (pyproject.toml/setup.py found)"
            elif [ -f "package.json" ]; then
              ARTIFACT_TYPE="nodejs"
              echo "ðŸ“¦ Detected Node.js project (package.json found)"
            else
              ARTIFACT_TYPE="generic"
              echo "â“ No specific project type detected, using generic"
            fi
          fi
          
          # Configure build parameters based on type
          case "$ARTIFACT_TYPE" in
            "go")
              echo "setup_command=echo 'Setting up Go...'" >> "$GITHUB_OUTPUT"
              echo "build_command=go build -o zobra-slsa-linux-amd64 . && GOOS=darwin GOARCH=amd64 go build -o zobra-slsa-darwin-amd64 . && GOOS=windows GOARCH=amd64 go build -o zobra-slsa-windows-amd64.exe ." >> "$GITHUB_OUTPUT"
              echo "artifact_pattern=zobra-slsa-*" >> "$GITHUB_OUTPUT"
              echo "artifact_path=." >> "$GITHUB_OUTPUT"
              ;;
            "python")
              echo "setup_command=python -m pip install --upgrade pip && pip install build" >> "$GITHUB_OUTPUT"
              echo "build_command=python -m build" >> "$GITHUB_OUTPUT"
              echo "artifact_pattern=*" >> "$GITHUB_OUTPUT"
              echo "artifact_path=dist" >> "$GITHUB_OUTPUT"
              ;;
            "nodejs")
              echo "setup_command=npm install" >> "$GITHUB_OUTPUT"
              echo "build_command=npm run build && npm pack" >> "$GITHUB_OUTPUT"
              echo "artifact_pattern=*.tgz" >> "$GITHUB_OUTPUT"
              echo "artifact_path=." >> "$GITHUB_OUTPUT"
              ;;
            "generic")
              BUILD_CMD="${{ github.event.inputs.build_command }}"
              PATTERN="${{ github.event.inputs.artifact_pattern }}"

              if [ -z "$BUILD_CMD" ]; then
                echo "âŒ Generic project detected but no build command provided"
                echo "ðŸ’¡ For universal auto-detection to work, you need:"
                echo "   1. A supported project type (go.mod, pyproject.toml, package.json)"
                echo "   2. OR manual inputs with artifact_type=generic and build_command"
                echo ""
                echo "ðŸ”§ Examples for unsupported languages:"
                echo "   Rust: artifact_type=generic, build_command='cargo build --release'"
                echo "   Java: artifact_type=generic, build_command='mvn clean package'"
                echo "   C++:  artifact_type=generic, build_command='make all'"
                echo ""
                echo "ðŸ“š See README_GENERIC_SLSA.md for complete examples"
                exit 1
              fi

              echo "setup_command=echo 'Generic setup - no specific setup required'" >> "$GITHUB_OUTPUT"
              echo "build_command=$BUILD_CMD" >> "$GITHUB_OUTPUT"
              echo "artifact_pattern=${PATTERN:-*}" >> "$GITHUB_OUTPUT"
              echo "artifact_path=." >> "$GITHUB_OUTPUT"
              ;;
          esac
          
          echo "artifact_type=$ARTIFACT_TYPE" >> "$GITHUB_OUTPUT"
          echo "âœ… Configuration complete for $ARTIFACT_TYPE"

  # Build artifacts based on detected/specified type
  build:
    needs: [detect]
    runs-on: ubuntu-latest
    permissions:
      contents: read
    outputs:
      hashes: ${{ steps.hash.outputs.hashes }}
      artifact_type: ${{ needs.detect.outputs.artifact_type }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.tag || github.ref }}

      # Setup environment based on artifact type
      - name: Setup Go
        if: needs.detect.outputs.artifact_type == 'go'
        uses: actions/setup-go@v4
        with:
          go-version: '1.21'

      - name: Setup Python
        if: needs.detect.outputs.artifact_type == 'python'
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'

      - name: Setup Node.js
        if: needs.detect.outputs.artifact_type == 'nodejs'
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      # Smart dependency installation for generic builds
      - name: Auto-install dependencies for generic builds
        if: needs.detect.outputs.artifact_type == 'generic'
        run: |
          set -euo pipefail
          echo "ðŸ” Analyzing build command for required dependencies..."

          BUILD_CMD="${{ needs.detect.outputs.build_command }}"
          echo "Build command: $BUILD_CMD"

          # Function to check if command exists
          command_exists() {
            command -v "$1" >/dev/null 2>&1
          }

          # Function to install Rust
          install_rust() {
            echo "ðŸ¦€ Installing Rust toolchain..."
            curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
            source ~/.cargo/env
            # Set environment variables for GitHub Actions
            echo "PATH=$PATH" >> $GITHUB_ENV
            echo "CARGO_HOME=$CARGO_HOME" >> $GITHUB_ENV
            echo "RUSTUP_HOME=$RUSTUP_HOME" >> $GITHUB_ENV
            echo "âœ… Rust installed: $(rustc --version)"
            echo "ðŸ”§ Rust environment configured for workflow"
          }

          # Function to install Zig
          install_zig() {
            echo "ðŸ¦Ž Installing Zig..."
            ZIG_VERSION="0.11.0"
            wget -q "https://ziglang.org/download/${ZIG_VERSION}/zig-linux-x86_64-${ZIG_VERSION}.tar.xz"
            tar -xf "zig-linux-x86_64-${ZIG_VERSION}.tar.xz"
            sudo mv "zig-linux-x86_64-${ZIG_VERSION}" /opt/zig
            sudo ln -sf /opt/zig/zig /usr/local/bin/zig
            # Add to PATH for current workflow
            echo "/opt/zig" >> $GITHUB_PATH
            echo "âœ… Zig installed: $(zig version)"
            echo "ðŸ”§ Zig environment configured for workflow"
          }

          # Function to install Maven
          install_maven() {
            echo "â˜• Installing Maven..."
            sudo apt-get update -q
            sudo apt-get install -y maven
            echo "âœ… Maven installed: $(mvn --version | head -1)"
          }

          # Function to install .NET
          install_dotnet() {
            echo "ðŸ”· Installing .NET SDK..."
            wget https://packages.microsoft.com/config/ubuntu/20.04/packages-microsoft-prod.deb -O packages-microsoft-prod.deb
            sudo dpkg -i packages-microsoft-prod.deb
            sudo apt-get update -q
            sudo apt-get install -y dotnet-sdk-8.0
            echo "âœ… .NET installed: $(dotnet --version)"
          }

          # Function to install CMake
          install_cmake() {
            echo "ðŸ—ï¸ Installing CMake..."
            sudo apt-get update -q
            sudo apt-get install -y cmake build-essential
            echo "âœ… CMake installed: $(cmake --version | head -1)"
          }

          # Function to install Ruby
          install_ruby() {
            echo "ðŸ’Ž Installing Ruby..."
            sudo apt-get update -q
            sudo apt-get install -y ruby-full rubygems
            echo "âœ… Ruby installed: $(ruby --version)"
          }

          # Function to install PHP
          install_php() {
            echo "ðŸ˜ Installing PHP and Composer..."
            sudo apt-get update -q
            sudo apt-get install -y php php-cli php-mbstring php-xml unzip
            curl -sS https://getcomposer.org/installer | php
            sudo mv composer.phar /usr/local/bin/composer
            echo "âœ… PHP installed: $(php --version | head -1)"
            echo "âœ… Composer installed: $(composer --version)"
          }

          # Detect and install required tools
          if echo "$BUILD_CMD" | grep -q "cargo"; then
            if ! command_exists cargo; then
              install_rust
            else
              echo "âœ… Rust already available: $(cargo --version)"
            fi
          fi

          if echo "$BUILD_CMD" | grep -q "zig"; then
            if ! command_exists zig; then
              install_zig
            else
              echo "âœ… Zig already available: $(zig version)"
            fi
          fi

          if echo "$BUILD_CMD" | grep -q "mvn"; then
            if ! command_exists mvn; then
              install_maven
            else
              echo "âœ… Maven already available: $(mvn --version | head -1)"
            fi
          fi

          if echo "$BUILD_CMD" | grep -q "dotnet"; then
            if ! command_exists dotnet; then
              install_dotnet
            else
              echo "âœ… .NET already available: $(dotnet --version)"
            fi
          fi

          if echo "$BUILD_CMD" | grep -q "cmake"; then
            if ! command_exists cmake; then
              install_cmake
            else
              echo "âœ… CMake already available: $(cmake --version | head -1)"
            fi
          fi

          if echo "$BUILD_CMD" | grep -q "gem build"; then
            if ! command_exists gem; then
              install_ruby
            else
              echo "âœ… Ruby already available: $(ruby --version)"
            fi
          fi

          if echo "$BUILD_CMD" | grep -q "composer"; then
            if ! command_exists composer; then
              install_php
            else
              echo "âœ… PHP/Composer already available: $(composer --version)"
            fi
          fi

          echo "ðŸŽ¯ Dependency installation complete!"

          # Universal environment refresh for all installed tools
          echo "ðŸ”„ Refreshing environment for all installed tools..."

          # Reload system environment
          source /etc/environment 2>/dev/null || true

          # Ensure common tool paths are in PATH
          export PATH="/usr/local/bin:/opt/zig:$HOME/.cargo/bin:$PATH"

          # Update GitHub Actions environment universally
          echo "PATH=$PATH" >> $GITHUB_ENV

          # Verify all tools are accessible
          echo "ðŸ” Verifying installed tools accessibility:"
          for tool in cargo rustc zig mvn dotnet cmake gem composer php; do
            if command -v "$tool" >/dev/null 2>&1; then
              echo "âœ… $tool: $(command -v $tool)"
            else
              echo "âŒ $tool: not found in PATH"
            fi
          done

          echo "ðŸŒ Universal environment setup complete!"



      # Run setup commands
      - name: Setup dependencies
        run: |
          echo "ðŸ”§ Running setup for ${{ needs.detect.outputs.artifact_type }}..."
          ${{ needs.detect.outputs.setup_command }}

      # Build artifacts
      - name: Build artifacts
        run: |
          echo "ðŸ—ï¸ Building artifacts for ${{ needs.detect.outputs.artifact_type }}..."
          echo "ðŸ”§ Build command: ${{ needs.detect.outputs.build_command }}"
          echo "ðŸ“ Working directory: $(pwd)"
          echo "ðŸ› ï¸ Available tools:"
          which cargo || echo "âŒ cargo not found"
          which rustc || echo "âŒ rustc not found"
          which zig || echo "âŒ zig not found"
          echo "ðŸŒ Environment:"
          echo "PATH=$PATH"
          echo "CARGO_HOME=$CARGO_HOME"
          echo "RUSTUP_HOME=$RUSTUP_HOME"

          echo "ðŸš€ Executing build command..."
          ${{ needs.detect.outputs.build_command }}
          
          echo "ðŸ“¦ Built artifacts:"
          if [ "${{ needs.detect.outputs.artifact_path }}" != "." ]; then
            ls -la "${{ needs.detect.outputs.artifact_path }}/" || echo "No artifacts in specified path"
          else
            ls -la ${{ needs.detect.outputs.artifact_pattern }} || echo "No artifacts matching pattern"
          fi

      # Generate hashes for SLSA provenance
      - name: Generate subject hashes
        id: hash
        run: |
          set -euo pipefail
          echo "ðŸ” Generating hashes for SLSA provenance..."
          
          cd "${{ needs.detect.outputs.artifact_path }}"
          
          # Find all files matching the pattern(s) - works for any artifact type
          echo "ðŸ” Looking for artifacts matching: ${{ needs.detect.outputs.artifact_pattern }}"

          # Use find to get only files (not directories) matching patterns
          ARTIFACT_FILES=$(find . -maxdepth 1 -type f \( -name "${{ needs.detect.outputs.artifact_pattern }}" \) 2>/dev/null || true)

          # If no files found with simple pattern, try expanding multiple patterns
          if [ -z "$ARTIFACT_FILES" ]; then
            echo "ðŸ”„ Trying expanded pattern matching..."
            ARTIFACT_FILES=""
            for pattern in ${{ needs.detect.outputs.artifact_pattern }}; do
              FILES=$(find . -maxdepth 1 -type f -name "$pattern" 2>/dev/null || true)
              if [ -n "$FILES" ]; then
                ARTIFACT_FILES="$ARTIFACT_FILES $FILES"
              fi
            done
          fi

          # Remove leading ./ and extra spaces
          ARTIFACT_FILES=$(echo $ARTIFACT_FILES | sed 's|./||g' | tr -s ' ')

          if [ -z "$ARTIFACT_FILES" ]; then
            echo "âŒ No artifacts found matching pattern: ${{ needs.detect.outputs.artifact_pattern }}"
            echo "ðŸ“ Contents of ${{ needs.detect.outputs.artifact_path }}:"
            ls -la
            echo "ðŸ” All files in directory:"
            find . -type f -maxdepth 2
            exit 1
          fi

          echo "ðŸ“‹ Found artifacts:"
          for file in $ARTIFACT_FILES; do
            ls -la "$file"
          done

          # Generate base64-encoded hashes as required by SLSA
          echo "hashes=$(sha256sum $ARTIFACT_FILES | base64 -w0)" >> "$GITHUB_OUTPUT"

          echo "âœ… Hash generation complete"
          echo "ðŸ“Š Generated hashes:"
          sha256sum $ARTIFACT_FILES

      # Upload artifacts for later verification
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: generic-slsa-artifacts-${{ needs.detect.outputs.artifact_type }}
          path: ${{ needs.detect.outputs.artifact_path }}

  # Generate SLSA provenance using the official generic generator
  provenance:
    needs: [build]
    permissions:
      actions: read   # To read the workflow path
      id-token: write # To sign the provenance
      contents: write # To add assets to a release
    uses: slsa-framework/slsa-github-generator/.github/workflows/generator_generic_slsa3.yml@v2.1.0
    with:
      base64-subjects: "${{ needs.build.outputs.hashes }}"
      upload-assets: true
      upload-tag-name: ${{ github.event.inputs.tag || github.ref_name }}
      provenance-name: "generic-slsa-provenance-${{ needs.build.outputs.artifact_type }}.intoto.jsonl"
