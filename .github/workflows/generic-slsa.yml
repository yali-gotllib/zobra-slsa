name: Generic SLSA Provenance

on:
  push:
    tags:
      - 'v*'
      - 'go-v*'
      - 'py-v*'
      - 'node-v*'
  workflow_dispatch:
    inputs:
      artifact_type:
        description: 'Type of artifact to build (auto, go, python, nodejs, generic)'
        required: false
        default: 'auto'
        type: choice
        options:
          - auto
          - go
          - python
          - nodejs
          - generic
      tag:
        description: 'Tag to generate provenance for'
        required: false
        default: ''
      build_command:
        description: 'Custom build command (for generic type)'
        required: false
        default: ''
      artifact_pattern:
        description: 'Pattern to match artifacts (for generic type)'
        required: false
        default: '*'

permissions: read-all

jobs:
  # Detect project type and configure build parameters
  detect:
    runs-on: ubuntu-latest
    outputs:
      artifact_type: ${{ steps.detect.outputs.artifact_type }}
      build_command: ${{ steps.detect.outputs.build_command }}
      setup_command: ${{ steps.detect.outputs.setup_command }}
      artifact_pattern: ${{ steps.detect.outputs.artifact_pattern }}
      artifact_path: ${{ steps.detect.outputs.artifact_path }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.tag || github.ref }}

      - name: Detect project type and configure build
        id: detect
        run: |
          set -euo pipefail
          
          # Use manual input if provided
          if [ "${{ github.event.inputs.artifact_type }}" != "auto" ] && [ "${{ github.event.inputs.artifact_type }}" != "" ]; then
            ARTIFACT_TYPE="${{ github.event.inputs.artifact_type }}"
            echo "ğŸ¯ Using manual artifact type: $ARTIFACT_TYPE"
          else
            # Auto-detect based on files present
            echo "ğŸ” Auto-detecting project type..."
            
            if [ -f "go.mod" ]; then
              ARTIFACT_TYPE="go"
              echo "ğŸ“¦ Detected Go project (go.mod found)"
            elif [ -f "pyproject.toml" ] || [ -f "setup.py" ] || [ -f "setup.cfg" ]; then
              ARTIFACT_TYPE="python"
              echo "ğŸ Detected Python project (pyproject.toml/setup.py found)"
            elif [ -f "package.json" ]; then
              ARTIFACT_TYPE="nodejs"
              echo "ğŸ“¦ Detected Node.js project (package.json found)"
            else
              ARTIFACT_TYPE="generic"
              echo "â“ No specific project type detected, using generic"
            fi
          fi
          
          # Configure build parameters based on type
          case "$ARTIFACT_TYPE" in
            "go")
              echo "setup_command=echo 'Setting up Go...'" >> "$GITHUB_OUTPUT"
              echo "build_command=go build -o zobra-slsa-linux-amd64 . && GOOS=darwin GOARCH=amd64 go build -o zobra-slsa-darwin-amd64 . && GOOS=windows GOARCH=amd64 go build -o zobra-slsa-windows-amd64.exe ." >> "$GITHUB_OUTPUT"
              echo "artifact_pattern=zobra-slsa-*" >> "$GITHUB_OUTPUT"
              echo "artifact_path=." >> "$GITHUB_OUTPUT"
              ;;
            "python")
              echo "setup_command=python -m pip install --upgrade pip && pip install build" >> "$GITHUB_OUTPUT"
              echo "build_command=python -m build" >> "$GITHUB_OUTPUT"
              echo "artifact_pattern=*" >> "$GITHUB_OUTPUT"
              echo "artifact_path=dist" >> "$GITHUB_OUTPUT"
              ;;
            "nodejs")
              echo "setup_command=npm install" >> "$GITHUB_OUTPUT"
              echo "build_command=npm run build && npm pack" >> "$GITHUB_OUTPUT"
              echo "artifact_pattern=*.tgz" >> "$GITHUB_OUTPUT"
              echo "artifact_path=." >> "$GITHUB_OUTPUT"
              ;;
            "generic")
              BUILD_CMD="${{ github.event.inputs.build_command }}"
              PATTERN="${{ github.event.inputs.artifact_pattern }}"

              if [ -z "$BUILD_CMD" ]; then
                echo "âŒ Generic project detected but no build command provided"
                echo "ğŸ’¡ For universal auto-detection to work, you need:"
                echo "   1. A supported project type (go.mod, pyproject.toml, package.json)"
                echo "   2. OR manual inputs with artifact_type=generic and build_command"
                echo ""
                echo "ğŸ”§ Examples for unsupported languages:"
                echo "   Rust: artifact_type=generic, build_command='cargo build --release'"
                echo "   Java: artifact_type=generic, build_command='mvn clean package'"
                echo "   C++:  artifact_type=generic, build_command='make all'"
                echo ""
                echo "ğŸ“š See README_GENERIC_SLSA.md for complete examples"
                exit 1
              fi

              echo "setup_command=echo 'Generic setup - no specific setup required'" >> "$GITHUB_OUTPUT"
              echo "build_command=$BUILD_CMD" >> "$GITHUB_OUTPUT"
              echo "artifact_pattern=${PATTERN:-*}" >> "$GITHUB_OUTPUT"
              echo "artifact_path=." >> "$GITHUB_OUTPUT"
              ;;
          esac
          
          echo "artifact_type=$ARTIFACT_TYPE" >> "$GITHUB_OUTPUT"
          echo "âœ… Configuration complete for $ARTIFACT_TYPE"

  # Build artifacts based on detected/specified type
  build:
    needs: [detect]
    runs-on: ubuntu-latest
    permissions:
      contents: read
    outputs:
      hashes: ${{ steps.hash.outputs.hashes }}
      artifact_type: ${{ needs.detect.outputs.artifact_type }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.tag || github.ref }}

      # Setup environment based on artifact type
      - name: Setup Go
        if: needs.detect.outputs.artifact_type == 'go'
        uses: actions/setup-go@v4
        with:
          go-version: '1.21'

      - name: Setup Python
        if: needs.detect.outputs.artifact_type == 'python'
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'

      - name: Setup Node.js
        if: needs.detect.outputs.artifact_type == 'nodejs'
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      # Smart dependency installation for generic builds
      - name: Auto-install dependencies for generic builds
        if: needs.detect.outputs.artifact_type == 'generic'
        run: |
          set -euo pipefail
          echo "ğŸ” Analyzing build command for required dependencies..."

          BUILD_CMD="${{ needs.detect.outputs.build_command }}"
          echo "Build command: $BUILD_CMD"

          # Function to check if command exists
          command_exists() {
            command -v "$1" >/dev/null 2>&1
          }

          # Function to install Rust
          install_rust() {
            echo "ğŸ¦€ Installing Rust toolchain..."
            curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
            source ~/.cargo/env
            # Set environment variables for GitHub Actions
            echo "PATH=$PATH" >> $GITHUB_ENV
            echo "CARGO_HOME=$CARGO_HOME" >> $GITHUB_ENV
            echo "RUSTUP_HOME=$RUSTUP_HOME" >> $GITHUB_ENV
            echo "âœ… Rust installed: $(rustc --version)"
            echo "ğŸ”§ Rust environment configured for workflow"
          }

          # Function to install Zig
          install_zig() {
            echo "ğŸ¦ Installing Zig..."
            ZIG_VERSION="0.11.0"
            wget -q "https://ziglang.org/download/${ZIG_VERSION}/zig-linux-x86_64-${ZIG_VERSION}.tar.xz"
            tar -xf "zig-linux-x86_64-${ZIG_VERSION}.tar.xz"
            sudo mv "zig-linux-x86_64-${ZIG_VERSION}" /opt/zig
            sudo ln -sf /opt/zig/zig /usr/local/bin/zig
            # Add to PATH for current workflow
            echo "/opt/zig" >> $GITHUB_PATH
            echo "âœ… Zig installed: $(zig version)"
            echo "ğŸ”§ Zig environment configured for workflow"
          }

          # Function to install Maven
          install_maven() {
            echo "â˜• Installing Maven..."
            sudo apt-get update -q
            sudo apt-get install -y maven
            echo "âœ… Maven installed: $(mvn --version | head -1)"
          }

          # Function to install .NET
          install_dotnet() {
            echo "ğŸ”· Installing .NET SDK..."
            wget https://packages.microsoft.com/config/ubuntu/20.04/packages-microsoft-prod.deb -O packages-microsoft-prod.deb
            sudo dpkg -i packages-microsoft-prod.deb
            sudo apt-get update -q
            sudo apt-get install -y dotnet-sdk-8.0
            echo "âœ… .NET installed: $(dotnet --version)"
          }

          # Function to install CMake
          install_cmake() {
            echo "ğŸ—ï¸ Installing CMake..."
            sudo apt-get update -q
            sudo apt-get install -y cmake build-essential
            echo "âœ… CMake installed: $(cmake --version | head -1)"
          }

          # Function to install Ruby
          install_ruby() {
            echo "ğŸ’ Installing Ruby..."
            sudo apt-get update -q
            sudo apt-get install -y ruby-full rubygems
            echo "âœ… Ruby installed: $(ruby --version)"
          }

          # Function to install PHP
          install_php() {
            echo "ğŸ˜ Installing PHP and Composer..."
            sudo apt-get update -q
            sudo apt-get install -y php php-cli php-mbstring php-xml unzip
            curl -sS https://getcomposer.org/installer | php
            sudo mv composer.phar /usr/local/bin/composer
            echo "âœ… PHP installed: $(php --version | head -1)"
            echo "âœ… Composer installed: $(composer --version)"
          }

          # UNIVERSAL: Extract and install ALL missing commands
          echo "ğŸ” Extracting commands from build command..."

          # Extract commands, excluding flags and common shell words
          COMMANDS=$(echo "$BUILD_CMD" | grep -oE '\b[a-zA-Z][a-zA-Z0-9_-]*\b' | \
                     grep -v '^[0-9]*$' | \
                     grep -v '^--' | \
                     grep -v '^-' | \
                     grep -v '^release$' | \
                     grep -v '^debug$' | \
                     grep -v '^build$' | \
                     grep -v '^clean$' | \
                     grep -v '^test$' | \
                     grep -v '^install$' | \
                     grep -v '^package$' | \
                     grep -v '^run$' | \
                     sort -u)
          echo "ğŸ“‹ Commands found: $COMMANDS"

          # Function to attempt universal installation
          universal_install() {
            local cmd="$1"
            echo "ğŸ”§ Attempting to install: $cmd"

            # Known installations (fast path)
            case "$cmd" in
              "cargo"|"rustc") install_rust ;;
              "zig") install_zig ;;
              "mvn") install_maven ;;
              "dotnet") install_dotnet ;;
              "cmake") install_cmake ;;
              "gem") install_ruby ;;
              "composer") install_php ;;
              "go")
                echo "ğŸ¹ Installing Go..."
                sudo rm -rf /usr/local/go
                wget -q https://go.dev/dl/go1.21.0.linux-amd64.tar.gz
                sudo tar -C /usr/local -xzf go1.21.0.linux-amd64.tar.gz
                echo "/usr/local/go/bin" >> $GITHUB_PATH
                echo "âœ… Go installed: $(/usr/local/go/bin/go version)"
                ;;
              "npm"|"node")
                echo "ğŸ“¦ Installing Node.js/NPM..."
                curl -fsSL https://deb.nodesource.com/setup_18.x | sudo -E bash -
                sudo apt-get install -y nodejs
                echo "âœ… Node.js installed: $(node --version)"
                ;;
              "pip"|"python3")
                echo "ğŸ Installing Python/pip..."
                sudo apt-get update -q
                sudo apt-get install -y python3 python3-pip
                echo "âœ… Python installed: $(python3 --version)"
                ;;
              "bazel")
                echo "ğŸ—ï¸ Installing Bazel..."
                curl -fsSL https://bazel.build/bazel-release.pub.gpg | gpg --dearmor > bazel.gpg
                sudo mv bazel.gpg /etc/apt/trusted.gpg.d/
                echo "deb [arch=amd64] https://storage.googleapis.com/bazel-apt stable jdk1.8" | sudo tee /etc/apt/sources.list.d/bazel.list
                sudo apt-get update -q && sudo apt-get install -y bazel
                echo "âœ… Bazel installed: $(bazel --version)"
                ;;
              "ninja")
                echo "ğŸ¥· Installing Ninja..."
                sudo apt-get update -q && sudo apt-get install -y ninja-build
                echo "âœ… Ninja installed: $(ninja --version)"
                ;;
              "scons")
                echo "ğŸ”¨ Installing SCons..."
                sudo apt-get update -q && sudo apt-get install -y scons
                echo "âœ… SCons installed: $(scons --version)"
                ;;
              "make")
                echo "ğŸ”§ Installing Make..."
                sudo apt-get update -q && sudo apt-get install -y build-essential
                echo "âœ… Make installed: $(make --version | head -1)"
                ;;
              *)
                # Universal fallback: try apt, snap, or warn
                echo "ğŸŒ Attempting universal installation for: $cmd"
                if sudo apt-get update -q && sudo apt-get install -y "$cmd" 2>/dev/null; then
                  echo "âœ… $cmd installed via apt"
                elif sudo snap install "$cmd" 2>/dev/null; then
                  echo "âœ… $cmd installed via snap"
                else
                  echo "âš ï¸ Could not auto-install $cmd - build may fail"
                  echo "ğŸ’¡ Consider adding manual installation for $cmd"
                fi
                ;;
            esac
          }

          # Check and install each command
          for cmd in $COMMANDS; do
            # Skip common shell keywords, operators, and build flags
            case "$cmd" in
              "if"|"then"|"else"|"fi"|"for"|"do"|"done"|"while"|"case"|"esac"|"function"|"return"|"exit"|"echo"|"cd"|"ls"|"mkdir"|"rm"|"cp"|"mv"|"cat"|"grep"|"sed"|"awk"|"sort"|"uniq"|"head"|"tail"|"wc"|"find"|"xargs"|"tar"|"gzip"|"gunzip"|"wget"|"curl"|"git"|"sudo"|"apt"|"snap"|"pip"|"sh"|"bash"|"zsh"|"fish"|"and"|"or"|"not"|"true"|"false"|"yes"|"no"|"with"|"from"|"import"|"export"|"set"|"unset"|"source"|"alias"|"which"|"type"|"command")
                echo "â­ï¸ Skipping shell keyword: $cmd"
                ;;
              *)
                if ! command_exists "$cmd"; then
                  universal_install "$cmd"
                else
                  echo "âœ… $cmd already available: $(command -v $cmd)"
                fi
                ;;
            esac
          done

          echo "ğŸ¯ Dependency installation complete!"

          # Universal environment refresh for all installed tools
          echo "ğŸ”„ Refreshing environment for all installed tools..."

          # Reload system environment
          source /etc/environment 2>/dev/null || true

          # Ensure common tool paths are in PATH
          export PATH="/usr/local/bin:/opt/zig:$HOME/.cargo/bin:$PATH"

          # Update GitHub Actions environment universally
          echo "PATH=$PATH" >> $GITHUB_ENV

          # Verify all tools are accessible
          echo "ğŸ” Verifying installed tools accessibility:"
          for tool in cargo rustc zig mvn dotnet cmake gem composer php; do
            if command -v "$tool" >/dev/null 2>&1; then
              echo "âœ… $tool: $(command -v $tool)"
            else
              echo "âŒ $tool: not found in PATH"
            fi
          done

          echo "ğŸŒ Universal environment setup complete!"



      # Run setup commands
      - name: Setup dependencies
        run: |
          echo "ğŸ”§ Running setup for ${{ needs.detect.outputs.artifact_type }}..."
          ${{ needs.detect.outputs.setup_command }}

      # Build artifacts
      - name: Build artifacts
        run: |
          echo "ğŸ—ï¸ Building artifacts for ${{ needs.detect.outputs.artifact_type }}..."
          echo "ğŸ”§ Build command: ${{ needs.detect.outputs.build_command }}"
          echo "ğŸ“ Working directory: $(pwd)"
          echo "ğŸ› ï¸ Available tools:"
          which cargo || echo "âŒ cargo not found"
          which rustc || echo "âŒ rustc not found"
          which zig || echo "âŒ zig not found"
          echo "ğŸŒ Environment:"
          echo "PATH=$PATH"
          echo "CARGO_HOME=$CARGO_HOME"
          echo "RUSTUP_HOME=$RUSTUP_HOME"

          echo "ğŸš€ Executing build command..."
          ${{ needs.detect.outputs.build_command }}
          
          echo "ğŸ“¦ Built artifacts:"
          if [ "${{ needs.detect.outputs.artifact_path }}" != "." ]; then
            ls -la "${{ needs.detect.outputs.artifact_path }}/" || echo "No artifacts in specified path"
          else
            ls -la ${{ needs.detect.outputs.artifact_pattern }} || echo "No artifacts matching pattern"
          fi

      # Generate hashes for SLSA provenance
      - name: Generate subject hashes
        id: hash
        run: |
          set -euo pipefail
          echo "ğŸ” Generating hashes for SLSA provenance..."

          cd "${{ needs.detect.outputs.artifact_path }}"

          # Universal artifact finding - works for any pattern and any project structure
          echo "ğŸ” Looking for artifacts matching: ${{ needs.detect.outputs.artifact_pattern }}"

          # Use shell globbing with nullglob for reliable pattern matching
          shopt -s nullglob
          shopt -s globstar

          # Convert pattern to array and find all matching files
          PATTERN="${{ needs.detect.outputs.artifact_pattern }}"
          ARTIFACT_FILES=()

          # Handle different pattern types universally
          if [[ "$PATTERN" == *"/"* ]]; then
            # Pattern contains path (e.g., "target/release/*", "dist/*", "build/*")
            for file in $PATTERN; do
              if [[ -f "$file" ]]; then
                ARTIFACT_FILES+=("$file")
              fi
            done
          else
            # Pattern is just filename (e.g., "*.jar", "*.exe", "*")
            # Search recursively for the pattern
            while IFS= read -r -d '' file; do
              ARTIFACT_FILES+=("$file")
            done < <(find . -type f -name "$PATTERN" -print0 2>/dev/null)
          fi

          # If still no files, try broader search patterns
          if [[ ${#ARTIFACT_FILES[@]} -eq 0 ]]; then
            echo "ğŸ”„ Trying broader pattern matching..."

            # Try common artifact locations with the pattern
            for dir in . target/release target/debug dist build out bin; do
              if [[ -d "$dir" ]]; then
                while IFS= read -r -d '' file; do
                  ARTIFACT_FILES+=("$file")
                done < <(find "$dir" -type f -name "$PATTERN" -print0 2>/dev/null)
              fi
            done
          fi

          # Remove duplicates and sort
          if [[ ${#ARTIFACT_FILES[@]} -gt 0 ]]; then
            readarray -t ARTIFACT_FILES < <(printf '%s\n' "${ARTIFACT_FILES[@]}" | sort -u)
          fi

          if [[ ${#ARTIFACT_FILES[@]} -eq 0 ]]; then
            echo "âŒ No artifacts found matching pattern: ${{ needs.detect.outputs.artifact_pattern }}"
            echo "ğŸ“ Contents of ${{ needs.detect.outputs.artifact_path }}:"
            ls -la
            echo "ğŸ” All files in directory tree:"
            find . -type f | head -20
            echo "ğŸ’¡ Common artifact locations to check:"
            for dir in target/release target/debug dist build out bin; do
              if [[ -d "$dir" ]]; then
                echo "ğŸ“‚ $dir/:"
                find "$dir" -type f | head -5
              fi
            done
            exit 1
          fi

          echo "ğŸ“‹ Found ${#ARTIFACT_FILES[@]} artifacts:"
          for file in "${ARTIFACT_FILES[@]}"; do
            ls -la "$file"
          done

          # Generate base64-encoded hashes as required by SLSA
          echo "hashes=$(sha256sum "${ARTIFACT_FILES[@]}" | base64 -w0)" >> "$GITHUB_OUTPUT"

          echo "âœ… Hash generation complete"
          echo "ğŸ“Š Generated hashes:"
          sha256sum "${ARTIFACT_FILES[@]}"

      # Upload artifacts for later verification
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: generic-slsa-artifacts-${{ needs.detect.outputs.artifact_type }}
          path: ${{ needs.detect.outputs.artifact_path }}

  # Generate SLSA provenance using the official generic generator
  provenance:
    needs: [detect, build]
    permissions:
      actions: read   # To read the workflow path
      id-token: write # To sign the provenance
      contents: write # To add assets to a release
    uses: slsa-framework/slsa-github-generator/.github/workflows/generator_generic_slsa3.yml@v2.1.0
    with:
      base64-subjects: "${{ needs.build.outputs.hashes }}"
      upload-assets: true
      upload-tag-name: ${{ github.event.inputs.tag || github.ref_name }}
      provenance-name: "generic-slsa-provenance-${{ needs.build.outputs.artifact_type }}.intoto.jsonl"
      private-repository: ${{ github.event.repository.private }}
